name: Update README on PR/Push (commit for same-repo, comment for forks)

on:
  push:
    branches:
      - '**'
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review, edited]

permissions:
  contents: write       # commit/push for same-repo branches
  pull-requests: write  # comment on PRs (forks)

concurrency:
  group: readme-on-${{ github.event_name }}-${{ github.event.pull_request.number || github.ref || github.run_id }}
  cancel-in-progress: false

jobs:
  update-readme:
    if: github.actor != 'github-actions[bot]' # avoid loops
    runs-on: ubuntu-latest

    steps:
      - name: ‚¨áÔ∏è Checkout target repo (base)
        uses: actions/checkout@v4
        with:
          # For push we‚Äôre already on the correct repo/ref
          repository: ${{ github.repository }}
          ref: ${{ github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üîÑ If PR: fetch PR head to a local branch (so we can patch correct README)
        if: ${{ github.event_name == 'pull_request_target' }}
        run: |
          PR_REPO="${{ github.event.pull_request.head.repo.full_name }}"
          PR_REF="${{ github.event.pull_request.head.ref }}"
          git remote add prhead "https://github.com/${PR_REPO}.git" || true
          git fetch prhead "${PR_REF}" --depth=0
          git checkout -B readme-pr-head FETCH_HEAD

      - name: üìù Build ‚ÄúWhat‚Äôs New‚Äù from this event‚Äôs commits and patch README (no push yet)
        id: patch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            const START = '<!-- START:WHATS_NEW -->';
            const END   = '<!-- END:WHATS_NEW -->';

            // Helpers
            const typeEmoji = (s) => {
              if (/^feat(\(|:)/i.test(s)) return '‚ú®';
              if (/^fix(\(|:)/i.test(s))  return 'üêõ';
              if (/^perf(\(|:)/i.test(s)) return '‚ö°';
              if (/^refactor(\(|:)/i.test(s)) return 'üßπ';
              if (/^build(\(|:)/i.test(s)) return 'üèóÔ∏è';
              if (/^style(\(|:)/i.test(s)) return 'üé®';
              return '‚Ä¢';
            };

            const noisePrefix = /^(chore|docs|test)(\(|:|$)/i;
            const noiseMsg    = /(dependabot|renovate|ci)/i;

            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;

            async function commitsFromPR() {
              const prNumber = context.payload.pull_request?.number;
              if (!prNumber) return [];
              const list = await github.paginate(
                github.rest.pulls.listCommits,
                { owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, per_page: 100 }
              );
              return list.map(c => ({
                sha: c.sha,
                subject: (c.commit?.message || '').split('\n')[0].trim()
              }));
            }

            async function commitsFromPush() {
              // Prefer commits from payload; fallback to compare API (handles bigger pushes)
              const p = context.payload;
              let raw = Array.isArray(p.commits) ? p.commits.map(c => ({
                sha: c.id,
                subject: (c.message || '').split('\n')[0].trim()
              })) : [];

              if (!raw.length && p.before && p.after) {
                const cmp = await github.rest.repos.compareCommits({
                  owner: context.repo.owner, repo: context.repo.repo,
                  base: p.before, head: p.after
                });
                raw = (cmp.data.commits || []).map(c => ({
                  sha: c.sha,
                  subject: (c.commit?.message || '').split('\n')[0].trim()
                }));
              }
              return raw;
            }

            async function getEventCommits() {
              if (context.eventName === 'pull_request_target') {
                return commitsFromPR();
              }
              if (context.eventName === 'push') {
                return commitsFromPush();
              }
              return [];
            }

            const rawCommits = await getEventCommits();

            // Filter, dedupe by subject, cap 20
            const seen = new Set();
            const items = [];
            for (const c of rawCommits) {
              const subj = (c.subject || '').trim();
              if (!subj) continue;
              if (/^merge/i.test(subj)) continue;
              if (noisePrefix.test(subj)) continue;
              if (noiseMsg.test(subj)) continue;

              const key = subj.toLowerCase();
              if (seen.has(key)) continue;
              seen.add(key);

              const clean = subj.replace(/^[a-z]+(\(.+?\))?:\s*/i, '');
              const short = c.sha.slice(0,7);
              items.push(`- ${typeEmoji(subj)} ${clean} ([${short}](${repoUrl}/commit/${c.sha}))`);
              if (items.length >= 20) break;
            }

            const bullets = items.length ? items.join('\n') : '_No relevant commits in this event._';

            // Patch README
            const readmePath = 'README.md';
            if (!fs.existsSync(readmePath)) {
              core.setFailed('README.md not found at repo root.');
              return;
            }
            let content = fs.readFileSync(readmePath, 'utf8');
            if (!content.includes(START) || !content.includes(END)) {
              core.setFailed('Markers not found in README.md. Add START/END markers first.');
              return;
            }

            // Optional version injection
            if (fs.existsSync('package.json') && content.includes('{{APP_VERSION}}')) {
              try {
                const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                content = content.replace(/{{APP_VERSION}}/g, pkg.version || '0.0.0');
              } catch {}
            }

            const block = `${START}\n${bullets}\n${END}`;
            const patched = content.replace(new RegExp(`${START}[\\s\\S]*?${END}`, 'm'), block);

            const changed = patched !== content;
            if (changed) fs.writeFileSync(readmePath, patched);

            // Outputs
            core.setOutput('changed', String(changed));
            core.setOutput('bullets', bullets);
            // isFork only relevant on PR events
            core.setOutput('isFork', String(!!context.payload.pull_request?.head?.repo?.fork));

      - name: üß™ Show diff (debug)
        if: steps.patch.outputs.changed == 'true'
        run: git --no-pager diff -- README.md || true

      - name: üîÅ Decide route (push vs comment) for PRs; pushes always commit
        id: route
        run: |
          if [ "${{ github.event_name }}" = "pull_request_target" ] && [ "${{ steps.patch.outputs.isFork }}" = "true" ]; then
            echo "route=comment" >> $GITHUB_OUTPUT
          else
            echo "route=push" >> $GITHUB_OUTPUT
          fi

      - name: ‚úÖ Commit & push to branch (push events and same-repo PRs)
        if: steps.patch.outputs.changed == 'true' && steps.route.outputs.route == 'push'
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "ü§ñ Update README: What‚Äôs New [skip ci]" || echo "No changes to commit"
          git push || echo "Nothing to push"

      - name: üí¨ Post/Update sticky PR comment (forked PRs)
        if: steps.patch.outputs.changed == 'true' && steps.route.outputs.route == 'comment'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: readme-whats-new
          number: ${{ github.event.pull_request.number }}
          message: |
            ### üìù README ‚ÄúWhat‚Äôs New‚Äù (preview)
            This PR comes from a fork, so I can‚Äôt push changes to your branch.
            Here‚Äôs what would be written into the README between the markers:

            ```
            ${{ steps.patch.outputs.bullets }}
            ```

            > Maintainers: If you want this committed, run locally on the PR branch or trigger the workflow with write perms.