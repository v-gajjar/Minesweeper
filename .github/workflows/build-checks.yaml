name: Update README on PR/Push (commit for same-repo, comment for forks)

on:
  push:
    branches:
      - '**'
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review, edited]

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: "readme-on-${{ github.event_name }}-${{ github.run_id }}"
  cancel-in-progress: false

jobs:
  update-readme:
    if: ${{ github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest

    steps:
      # Checkout for PUSH events
      - name: ‚¨áÔ∏è Checkout (push)
        if: ${{ github.event_name == 'push' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # Checkout the PR HEAD for PR events (no bash/env trickery)
      - name: ‚¨áÔ∏è Checkout PR head (pull_request_target)
        if: ${{ github.event_name == 'pull_request_target' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üìù Build ‚ÄúWhat‚Äôs New‚Äù from this event‚Äôs commits and patch README (no push yet)
        id: patch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            const START = '<!-- START:WHATS_NEW -->';
            const END   = '<!-- END:WHATS_NEW -->';

            const typeEmoji = (s) => {
              if (/^feat(\(|:)/i.test(s)) return '‚ú®';
              if (/^fix(\(|:)/i.test(s))  return 'üêõ';
              if (/^perf(\(|:)/i.test(s)) return '‚ö°';
              if (/^refactor(\(|:)/i.test(s)) return 'üßπ';
              if (/^build(\(|:)/i.test(s)) return 'üèóÔ∏è';
              if (/^style(\(|:)/i.test(s)) return 'üé®';
              return '‚Ä¢';
            };

            const noisePrefix = /^(chore|docs|test)(\(|:|$)/i;
            const noiseMsg    = /(dependabot|renovate|ci)/i;

            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;

            async function commitsFromPR() {
              const prNumber = context.payload.pull_request?.number;
              if (!prNumber) return [];
              const list = await github.paginate(
                github.rest.pulls.listCommits,
                { owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, per_page: 100 }
              );
              return list.map(c => ({
                sha: c.sha,
                subject: (c.commit?.message || '').split('\n')[0].trim()
              }));
            }

            async function commitsFromPush() {
              const p = context.payload;
              let raw = Array.isArray(p.commits) ? p.commits.map(c => ({
                sha: c.id,
                subject: (c.message || '').split('\n')[0].trim()
              })) : [];

              if (!raw.length && p.before && p.after) {
                const cmp = await github.rest.repos.compareCommits({
                  owner: context.repo.owner, repo: context.repo.repo,
                  base: p.before, head: p.after
                });
                raw = (cmp.data.commits || []).map(c => ({
                  sha: c.sha,
                  subject: (c.commit?.message || '').split('\n')[0].trim()
                }));
              }
              return raw;
            }

            async function getEventCommits() {
              if (context.eventName === 'pull_request_target') return commitsFromPR();
              if (context.eventName === 'push') return commitsFromPush();
              return [];
            }

            const rawCommits = await getEventCommits();

            const seen = new Set();
            const items = [];
            for (const c of rawCommits) {
              const subj = (c.subject || '').trim();
              if (!subj) continue;
              if (/^merge/i.test(subj)) continue;
              if (noisePrefix.test(subj)) continue;
              if (noiseMsg.test(subj)) continue;

              const key = subj.toLowerCase();
              if (seen.has(key)) continue;
              seen.add(key);

              const clean = subj.replace(/^[a-z]+(\(.+?\))?:\s*/i, '');
              const short = c.sha.slice(0,7);
              items.push(`- ${typeEmoji(subj)} ${clean} ([${short}](${repoUrl}/commit/${c.sha}))`);
              if (items.length >= 20) break;
            }

            const bullets = items.length ? items.join('\n') : '_No relevant commits in this event._';

            const readmePath = 'README.md';
            if (!fs.existsSync(readmePath)) {
              core.setFailed('README.md not found at repo root.');
              return;
            }
            let content = fs.readFileSync(readmePath, 'utf8');
            if (!content.includes(START) || !content.includes(END)) {
              core.setFailed('Markers not found in README.md. Add START/END markers first.');
              return;
            }

            if (fs.existsSync('package.json') && content.includes('{{APP_VERSION}}')) {
              try {
                const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                content = content.replace(/{{APP_VERSION}}/g, pkg.version || '0.0.0');
              } catch {}

            }

            const block = `${START}\n${bullets}\n${END}`;
            const patched = content.replace(new RegExp(`${START}[\\s\\S]*?${END}`, 'm'), block);

            const changed = patched !== content;
            if (changed) fs.writeFileSync(readmePath, patched);

            core.setOutput('changed', String(changed));
            core.setOutput('bullets', bullets);
            core.setOutput('isFork', String(!!context.payload.pull_request?.head?.repo?.fork));

      - name: üß™ Show diff (debug)
        if: ${{ steps.patch.outputs.changed == 'true' }}
        run: git --no-pager diff -- README.md || true

      - name: üîÅ Decide route (push vs comment) for PRs; pushes always commit
        id: route
        run: |
          if [ "${{ github.event_name }}" = "pull_request_target" ] && [ "${{ steps.patch.outputs.isFork }}" = "true" ]; then
            echo "route=comment" >> $GITHUB_OUTPUT
          else
            echo "route=push" >> $GITHUB_OUTPUT
          fi

      - name: ‚úÖ Commit & push to branch (push events and same-repo PRs)
        if: ${{ steps.patch.outputs.changed == 'true' && steps.route.outputs.route == 'push' }}
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "ü§ñ Update README: What‚Äôs New [skip ci]" || echo "No changes to commit"
          git push || echo "Nothing to push"

      - name: üí¨ Post/Update sticky PR comment (forked PRs)
        if: ${{ steps.patch.outputs.changed == 'true' && steps.route.outputs.route == 'comment' }}
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: readme-whats-new
          number: "${{ github.event.pull_request.number }}"
          message: |
            ### üìù README ‚ÄúWhat‚Äôs New‚Äù (preview)
            This PR comes from a fork, so I can‚Äôt push changes to your branch.
            Here‚Äôs what would be written into the README between the markers:

            ```
            ${{ steps.patch.outputs.bullets }}
            ```

            > Maintainers: If you want this committed, run locally on the PR branch or trigger the workflow with write perms.